<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ICMP Redirect Attack</title>
      <link href="/2018/04/12/ICMP-Redirect-Attack/"/>
      <url>/2018/04/12/ICMP-Redirect-Attack/</url>
      <content type="html"><![CDATA[<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>ICMP协议的redirect,在某些特定的环境下,还是有些用处的。具体的可以参看:<br><a href="http://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094702.shtml" target="_blank" rel="noopener">When Are ICMP Redirects Sent</a><br><a href="http://support.microsoft.com/kb/195686/en-us/" target="_blank" rel="noopener">Explanation of ICMP Redirect Behavior</a></p><p>由于ICMP redirect可以动态的更改host的路由,从安全角度考虑,允许accept ICMP redirect的信息话带来的弊大于利。因此在<em>系统加固</em>的手册中,往往都建议将icmp redirect丢弃掉。</p><p>我想知道的是,在系统默认的配置下。通过构造特定ICMP redirect的数据包,被攻击者是否真的会受到影响；以及需要满足什么样的条件?</p><h4 id="icmp-redirect-packet"><a href="#icmp-redirect-packet" class="headerlink" title="icmp redirect packet"></a>icmp redirect packet</h4><p>一个标准的icmp redirect packet 如下所示:<br>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>| Type | Code | Checksum |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>| Gateway Internet Address |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>| Internet Header + 64 bits of Original Data Datagram |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br><strong>TYPE</strong>为5,表示为一个icmp redirect类数据；<br><strong>Code</strong>有4类:</p><blockquote><p>0 = Redirect datagrams for the Network.<br>1 = Redirect datagrams for the Host.<br>2 = Redirect datagrams for the Type of Service and Network.<br>3 = Redirect datagrams for the Type of Service and Host.</p></blockquote><p>其中Code为0的这类,在microsoft网站的文档中显示已经被废除掉了；我通过测试发现,Code设置为0和1是没有什么区别。</p><h4 id="icmp-redirect-processes"><a href="#icmp-redirect-processes" class="headerlink" title="icmp redirect processes"></a>icmp redirect processes</h4><p>一个正常的icmp redirect过程是这样的,host_A希望访问remote_A的tcp 123端口,当数据包发送到gateway_A,gateway_A发现到remote_A的路由应该走和host_A同网段的host_B,因此就会发 送一个icmp redirect信息,告诉你要访问remote_A的路由应该是走host_B,因此host_A就临时修改路由表,将访问remote_A的路由指向 host_B。</p><p>其实,操作系统设计人员,已经考虑到了可能会受到的攻击,因此当host_A收到icmp redirect数据时,会对该数据包进行验证,通过后才会修改自己的路由表。一下是我在freebsd6.2-7.2和linux center-os 5.2下测试的结果:<br>freebsd：</p><ol><li>icmp redirect数据包的的源ip地址必须是主机的default gateway;</li><li>remote_A必须和自己不是同一个网段;<br>linux: </li><li>icmp redirect数据包的的源ip地址必须是主机的default gateway;</li><li>remote_A必须和自己不是同一个网段;</li><li>先前有发送访问remote_A的数据包，但是并不验证协议和端口号是否和icmp redirect回应的数据包相符。<br>4.host_B是存活的——可以通过arp学到host_B的mac地址。</li></ol><p>从 以上这些限制中,可以看出linux比freebsd在icmp redirect这块儿是要严格一些。但是依然可以通过发送伪造的icmp redirect数据包,恶意修改被攻击者的路由表,修改被攻击者和特定ip之间的网络路径;实现流量劫持或者DoS的目的。更重要的是经过验证,该攻击 是可以跨网段的。</p><h3 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h3><p>假设一台放在IDC内的服务器,操作系统为freebsd,ip地址为1.1.1.5。我们通过扫描,能够猜测到网关为1.1.1.1。这样我们可以从一台直接连接到互联网上的机器发起攻击(直接连接互联网的原因是为了避免SNAT)。使用<a href="http://sourceforge.net/projects/sing/" target="_blank" rel="noopener">SING</a>伪造ICMP攻击数据包:</p><pre><code>./sing -red -gw 1.1.1.4 -dest x.x.x.x -S 1.1.1.1 -x host -prot tcp -psrc 123 -pdst 123 1.1.1.5</code></pre><p>这样,当freebsd接受到该icmp redirect数据包后,就会在路由表中添加一条到x.x.x.x的路由,该路由gw为1.1.1.4,可以通过netstat -rn查看。</p><pre><code>Destination Gateway Flags Refs Use Netif Expiredefault 1.1.1.1 UGS 0 11164121 em1x.x.x.x 1.1.1.4 UGHD3 0 0 em1 3600</code></pre><p>……<br>过期时间为3600秒。如果1.1.1.4是不存在的ip或者没有转发功能,那么这台机器到x.x.x.x的网络将会中断。</p><p>如果针对linux的话,可能会有些限制。针对上个例子,就要求1.1.1.4这台机器是存活的同网段主机,不过这里机器应该不难找。</p><h3 id="危害分析"><a href="#危害分析" class="headerlink" title="危害分析"></a>危害分析</h3><p>这 类攻击有一个很大的限制,就是一个icmp redirect只能影响受攻击者和单独一个ip地址之间的正常通信;无法造成受攻击者完全被DoS。但是在具体的应用环境中,可以对一些关键设备实施攻 击,从而造成比较大的影响;毕竟对攻击者来说,发送几个icmp数据包的成本还是比较低的。例如:针对DNS服务器,可以将从A-M的的几个root server的ip地址通过icmp redirect,那么应该会造成影响(当然也要看具体DNS服务器的服务类型)。</p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p>找到system内核参数配置文件/etc/sysctl.conf：</p><p>修改：</p><pre><code>#################################################################### Additional settings - these settings can improve the network# security of the host and prevent against some network attacks# including spoofing attacks and man in the middle attacks through# redirection. Some network environments, however, require that these# settings are disabled so review and enable them as needed.## Do not accept ICMP redirects (prevent MITM attacks)#net.ipv4.conf.all.accept_redirects = 0#net.ipv6.conf.all.accept_redirects = 0# _or_# Accept ICMP redirects only for gateways listed in our default# gateway list (enabled by default)# net.ipv4.conf.all.secure_redirects = 1## Do not send ICMP redirects (we are not a router)#net.ipv4.conf.all.send_redirects = 0`</code></pre><p>为</p><pre><code>#################################################################### Additional settings - these settings can improve the network# security of the host and prevent against some network attacks# including spoofing attacks and man in the middle attacks through# redirection. Some network environments, however, require that these# settings are disabled so review and enable them as needed.## Do not accept ICMP redirects (prevent MITM attacks)net.ipv4.conf.all.accept_redirects = 0net.ipv6.conf.all.accept_redirects = 0# _or_# Accept ICMP redirects only for gateways listed in our default# gateway list (enabled by default)# net.ipv4.conf.all.secure_redirects = 1## Do not send ICMP redirects (we are not a router)net.ipv4.conf.all.send_redirects = 0</code></pre><p>然后应用内核参数配置</p><pre><code>$ sudo sysctl -p</code></pre><p><strong>reference</strong><br><a href="http://www.cymru.com/gillsr/documents/icmp-redirects-are-bad.pdf" target="_blank" rel="noopener">http://www.cymru.com/gillsr/documents/icmp-redirects-are-bad.pdf</a><br><a href="http://sourceforge.net/projects/sing/" target="_blank" rel="noopener">http://sourceforge.net/projects/sing/</a><br><a href="http://tools.ietf.org/html/rfc792" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc792</a></p>]]></content>
      
      <categories>
          
          <category> security </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> route </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux look up route</title>
      <link href="/2018/04/11/Linux-look-for-route-table/"/>
      <url>/2018/04/11/Linux-look-for-route-table/</url>
      <content type="html"><![CDATA[<p>本文介绍几种获取linux当前系统路由表的命令</p><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><pre><code>[root@localhost ~]# routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         192.168.150.1   0.0.0.0         UG    1024   0        0 eno16780032192.168.150.0   0.0.0.0         255.255.255.0   U     0      0        0 eno16780032</code></pre><h3 id="ip-rule"><a href="#ip-rule" class="headerlink" title="ip rule"></a>ip rule</h3><pre><code>[root@localhost ~]# ip rule0:    from all lookup local 32766:    from all lookup main 32767:    from all lookup default</code></pre><h3 id="ip-route-list-table"><a href="#ip-route-list-table" class="headerlink" title="ip route list table"></a>ip route list table</h3><pre><code>[root@localhost ~]# ip route list table alldefault via 192.168.150.1 dev eno16780032  proto static  metric 1024 192.168.150.0/24 dev eno16780032  proto kernel  scope link  src 192.168.150.151 broadcast 127.0.0.0 dev lo  table local  proto kernel  scope link  src 127.0.0.1 local 127.0.0.0/8 dev lo  table local  proto kernel  scope host  src 127.0.0.1 local 127.0.0.1 dev lo  table local  proto kernel  scope host  src 127.0.0.1 broadcast 127.255.255.255 dev lo  table local  proto kernel  scope link  src 127.0.0.1 broadcast 192.168.150.0 dev eno16780032  table local  proto kernel  scope link  src 192.168.150.151 local 192.168.150.151 dev eno16780032  table local  proto kernel  scope host  src 192.168.150.151 broadcast 192.168.150.255 dev eno16780032  table local  proto kernel  scope link  src 192.168.150.151 local ::1 dev lo  proto kernel  metric 256 unreachable ::/96 dev lo  metric 1024  error -101unreachable ::ffff:0.0.0.0/96 dev lo  metric 1024  error -101unreachable 2002:a00::/24 dev lo  metric 1024  error -101unreachable 2002:7f00::/24 dev lo  metric 1024  error -101unreachable 2002:a9fe::/32 dev lo  metric 1024  error -101unreachable 2002:ac10::/28 dev lo  metric 1024  error -101unreachable 2002:c0a8::/32 dev lo  metric 1024  error -101unreachable 2002:e000::/19 dev lo  metric 1024  error -101unreachable 3ffe:ffff::/32 dev lo  metric 1024  error -101fe80::/64 dev eno16780032  proto kernel  metric 256 unreachable default dev lo  table unspec  proto kernel  metric 4294967295  error -101local ::1 dev lo  table local  proto none  metric 0 local fe80::20c:29ff:fe9f:7ea6 dev lo  table local  proto none  metric 0 ff00::/8 dev eno16780032  table local  metric 256 unreachable default dev lo  table unspec  proto kernel  metric 4294967295  error -101</code></pre><h3 id="ip-route-get"><a href="#ip-route-get" class="headerlink" title="ip route get"></a>ip route get</h3><pre><code>[root@localhost ~]# ip route get 114.114.114.114114.114.114.114 via 192.168.150.1 dev eno16780032  src 192.168.150.151 </code></pre>]]></content>
      
      <categories>
          
          <category> linux </category>
          
          <category> command </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> route </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web缓存之：基础知识</title>
      <link href="/2018/04/10/web-cache-basic-kb/"/>
      <url>/2018/04/10/web-cache-basic-kb/</url>
      <content type="html"><![CDATA[<blockquote><p>Caching is a technique that stores a copy of a given resource and serves it back when requested. When a web cache has a requested resource in its store, it intercepts the request and returns its copy instead of re-downloading from the originating server.</p></blockquote><p><em>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。</em></p><h3 id="Advantagement-of-Web-Cache"><a href="#Advantagement-of-Web-Cache" class="headerlink" title="Advantagement of Web Cache"></a>Advantagement of Web Cache</h3><ul><li>Improving the performance by reusing previously fetched resources. </li><li>Reducing latency and network traffic.</li><li>Web sites become more responsive.</li></ul><h3 id="Different-kinds-of-caches"><a href="#Different-kinds-of-caches" class="headerlink" title="Different kinds of caches"></a>Different kinds of caches</h3><p>Cache从作用和部署位置来说有好几种类型：gateway caches, CDN, reverse proxy caches and load balancers 。这些有利于Web Server提高可用性，提升性能和横向扩展*<br><img src="/2018/04/10/web-cache-basic-kb/CacheCategory.png" class="CacheCategory">  </p><h4 id="Reverse-Proxy-Cache"><a href="#Reverse-Proxy-Cache" class="headerlink" title="Reverse Proxy Cache"></a>Reverse Proxy Cache</h4><p>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等，这里不再详述。</p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><h4 id="Web应用层缓存"><a href="#Web应用层缓存" class="headerlink" title="Web应用层缓存"></a>Web应用层缓存</h4><p>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</p><h4 id="浏览器端缓存"><a href="#浏览器端缓存" class="headerlink" title="浏览器端缓存"></a>浏览器端缓存</h4><p>浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。</p><h4 id="SQL-Cache"><a href="#SQL-Cache" class="headerlink" title="SQL Cache"></a>SQL Cache</h4><p>Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached等。</p><h3 id="Controlling-caching"><a href="#Controlling-caching" class="headerlink" title="Controlling caching"></a>Controlling caching</h3><p>The header: <strong>Cache-control</strong> </p><blockquote><p>The Cache-Control HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</p></blockquote><p><em>HTTP1.1版本才添加的缓存控制机制，其在请求报文或响应报文首部添加一个cache-control的首部，用于定义资源的缓存最大时长，是相对于响应报文首部中的date首部定义的时间。一般响应报文首部会同时有Expires首部和Cache-control首部</em></p><h4 id="No-cache-storage-at-all"><a href="#No-cache-storage-at-all" class="headerlink" title="No cache storage at all"></a>No cache storage at all</h4><blockquote><p>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.<br><em>完全不缓存</em></p></blockquote><pre><code>Cache-Control: no-storeCache-Control: no-cache, no-store, must-revalidate</code></pre><h4 id="No-caching"><a href="#No-caching" class="headerlink" title="No caching"></a>No caching</h4><blockquote><p>A cache will send the request to the origin server for validation before releasing a cached copy.<br><em>会缓存，但是每次请求都会确认</em></p></blockquote><pre><code>Cache-Control: no-cache</code></pre><h4 id="Private-and-public-caches"><a href="#Private-and-public-caches" class="headerlink" title="Private and public caches"></a>Private and public caches</h4><p>Private Cache 只能被单个用户使用。Public Cache可以被多个用户复用。</p><pre><code>Cache-Control: privateCache-Control: public</code></pre><h4 id="Expiration"><a href="#Expiration" class="headerlink" title="Expiration"></a>Expiration</h4><p>The most important directive here is “max-age=&lt;seconds>“ which is the maximum amount of time a resource will be considered fresh. Contrary to Expires, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</p><p>For more details, see also the <strong>Freshness</strong> section below.</p><pre><code>Cache-Control: max-age=31536000</code></pre><h4 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h4><p>When using the “must-revalidate” directive, the cache must verify the status of the stale resources before using it and expired ones should not be used. For more details, see the <strong>Validation</strong> section below.</p><pre><code>Cache-Control: must-revalidate</code></pre><p>对Cache-Control头不同的值归纳 </p><pre><code>    cache-request-directive=no-cache 不接受缓存响应                            no-store 不缓存在本地                            max-age  缓存最大有效时长                                   min-fresh     cache-response-directive=public                             private                             no-cache                              no-store                             must-revalidate                             max-age    // no-cache：可缓存，但用户每次请求都需要先到上游服务器做缓存检验</code></pre><h4 id="The-Pragma-header"><a href="#The-Pragma-header" class="headerlink" title="The Pragma header"></a>The Pragma header</h4><p>Pragma 是一个 HTTP/1.0 header，在HTTP/1.1中并没有定义它为一个HTTP response头，因为我们已经有了 Cache-Control header。这个只是为了兼容HTTP/1.0的客户端。</p><pre><code>&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</code></pre><p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。</p><p>可以通过这个页面测试你的浏览器是否支持：<a href="http://www.procata.com/cachetest/tests/pragma/index.php" target="_blank" rel="noopener">Pragma No-Cache Test</a></p><h4 id="Varying-responses"><a href="#Varying-responses" class="headerlink" title="Varying responses"></a>Varying responses</h4><p><strong>Vary</strong> response header从在Client上多个不同的cache副本筛选合适的版本</p><blockquote><p>The Vary HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</p></blockquote><blockquote><p>When a cache receives a request that can be satisfied by a cached response that has a Vary header field, it must not use that cached response unless all header fields as nominated by the Vary header match in both the original (cached) request and the new request.</p></blockquote><blockquote><p>The Vary header leads cache to use more HTTP headers as key for the cache.</p></blockquote><blockquote><p>This can be useful for serving content dynamically, for example. When using the Vary: User-Agent header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no Cloaking is intended.</p></blockquote><blockquote><p>Because the User-Agent header value is different (“varies”) for mobile and desktop clients, caches will not be used to serve mobile content mistakenly to desktop users or vice versa.</p></blockquote><h3 id="Freshness"><a href="#Freshness" class="headerlink" title="Freshness"></a>Freshness</h3><p>新鲜度:资源被存储到缓存后，必须要有回收机制（cache eviction）以释放占用的存储空间；另外因为Web资源可能会不停地更新，缓存也需要过期机制（expiration time），也就是缓存副本有效期。</p><h4 id="Cache-eviction"><a href="#Cache-eviction" class="headerlink" title="Cache eviction"></a>Cache eviction</h4><ol><li>缓存项过期：缓存资源往往会被设置有效时长，过期自动清理或失效</li><li>缓存空间用尽：缓存空间用尽时，会根据LRU（最近最小使用）算法清理缓存</li><li>清理策略设置过长过短都不好，过长数据容易陈旧，过短起不到缓存效果</li></ol><h4 id="Lifetime"><a href="#Lifetime" class="headerlink" title="Lifetime"></a>Lifetime</h4><p>Show how a proxy cache acts when a doc is not cache, in the cache and fresh, in the cache and stale. Here is an example of this process with a shared cache proxy:</p><img src="/2018/04/10/web-cache-basic-kb/HTTPStaleness.png" class="HTTPStaleness"><p>flow as follows:<br><img src="/2018/04/10/web-cache-basic-kb/FreshnessLifetime.png" class="FreshnessLifetime"></p><ol><li>是否过期（expeired）通过”<strong>Cache-control: max-age=N</strong>“ header 或者 <strong>Expires</strong> header 判断。<strong>max-age</strong>根据<strong>Date</strong>header和<strong>N</strong>判读是否expired；<strong>Expires</strong>则会直接记录expiration time.</li><li><strong>Etag</strong> header记录的是resource文件的MD5值，通过MD5判断server上该文件是否有改动。</li><li><strong>Last-Modified</strong>记录resource文件最后update时间，精确到秒。  </li></ol><p><strong>Cache-Control与Expires</strong><br>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p><p><strong>Last-Modified/ETag与Cache-Control/Expires</strong><br>配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；</p><p>Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。</p><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。</p><p><strong>Last-Modified与ETag</strong><br>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度,属于弱检验（weak validator）</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li><li>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。属于强检验（strong validator）</li><li>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</li><li>Etag的服务器生成规则和强弱Etag的相关内容可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="noopener">《HTTP Header definition》</a>，    </li></ul><h3 id="Reused-resources"><a href="#Reused-resources" class="headerlink" title="Reused resources"></a>Reused resources</h3><p>并非所有的数据被缓存或需要缓存，缓存是为了解决20%数据被80%的人频繁访问的问题而生。所有我们必须要考虑缓存的复用率。</p><h4 id="The-data-we-cache"><a href="#The-data-we-cache" class="headerlink" title="The data we cache"></a>The data we cache</h4><p>数据如希望被缓存往往具备变化缓慢的特征。被缓存的数据往往具备如下特性：</p><p><strong>时间局部性</strong><br>缓存的数据往往被打有时间缀，具有定期失效的特征，过期后会从源服务器检验请求验证是否需要重新拉取数据。<br>某数据被访问后，该数据往往会再次在短时间内被访问到。</p><p><strong>空间局部性</strong><br>被访问数据的周边数据被访问的概率会比其它常规数据访问大很多，所以这些访问数据和其它周边有可能被访问的数据通过某种方式集中在一起，以提高数据的被访问速度，减少数据查找时长。<br>完成这类功能的工具往往称为Cache。</p><p><strong>热（区）数据</strong><br>所谓热（区）数据就是指经常被访问到的数据，这类数据被缓存最有价值，缓存命中率高</p><h4 id="The-data-we-do-not-cache"><a href="#The-data-we-do-not-cache" class="headerlink" title="The data we do not cache"></a>The data we do not cache</h4><p>用户账号密码信息等数据，该类数据不仅不应该被缓存，反而要被着重保护，这些年发生的撞库，密码破解等恶性事件，往往都是因为用户个人不当心或企业安全意味不足，导致用户敏感信息流失。</p><h4 id="Cache-hit"><a href="#Cache-hit" class="headerlink" title="Cache hit"></a>Cache hit</h4><p>缓存命中率=hit/(hit+mixx)<br>hit表示缓存被命中，miss表示没有命中，也就是缓存项中没有对应的资源<br>文档命中率：从文档命中的个数进行衡量<br>字节命中率：从内容命中的大小(字节)进行衡量</p><p> This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</p><img src="/2018/04/10/web-cache-basic-kb/HTTPRevved.png" class="HTTPRevved"><h3 id="Can-NOT-Caches"><a href="#Can-NOT-Caches" class="headerlink" title="Can NOT Caches"></a>Can NOT Caches</h3><p>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求<br>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的<br>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）<br>POST请求无法被缓存<br>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> cache </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Learning</title>
      <link href="/2018/04/05/Hexo-Learning/"/>
      <url>/2018/04/05/Hexo-Learning/</url>
      <content type="html"><![CDATA[<p><em>作为搭建个人blog最为重要的组件，Hexo可以说是最核心的部分，不仅是因为它提供了基本的框架，而且还有丰富的扩展包，自定义主题格式等丰富功能，最重要的是作为新手来说简洁易懂。</em></p><h3 id="what-is-Hexo"><a href="#what-is-Hexo" class="headerlink" title="what is Hexo?"></a>what is Hexo?</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装前提<br>在安装前，已安装下列应用程序：<br>Node.js<br>Git</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="建站（本地）"><a href="#建站（本地）" class="headerlink" title="建站（本地）"></a>建站（本地）</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>新建完成后，指定文件夹的目录如下：  </p><blockquote><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|     ├── _drafts<br>|     └── _posts<br>└── themes</p></blockquote><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p><strong>_config.yml</strong> – 网站的 配置 信息，您可以在此配置大部分的参数。<br><strong>package.json</strong> – 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。  </p><pre><code>{  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: {    &quot;version&quot;: &quot;&quot;  },  &quot;dependencies&quot;: {    &quot;hexo&quot;: &quot;^3.0.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;,    &quot;hexo-server&quot;: &quot;^0.1.2&quot;  }}</code></pre><p><strong>scaffolds</strong> – 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong> – 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。<br><strong>themes</strong> – 主题 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="Tag-Plugins"><a href="#Tag-Plugins" class="headerlink" title="Tag Plugins"></a>Tag Plugins</h3><p><strong>Quota</strong></p><pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %}</code></pre><p><strong>Code</strong></p><pre><code>{% codeblock [title] [lang:language] [url] [link text] %}code snippet{% endcodeblock %}</code></pre><p><strong>Image</strong></p><pre><code>{% img [class names] /path/to/image [width] [height] [title text [alt text]] %}</code></pre><p><em>path start with the public folder</em></p><h3 id="Hexo-extension-packages"><a href="#Hexo-extension-packages" class="headerlink" title="Hexo extension packages"></a>Hexo extension packages</h3><p><strong>deploy to git website</strong>  </p><pre><code>$ npm install hexo-deployer-git --save$ hexo d -g</code></pre><p><strong>enable search feature</strong></p><pre><code>$ npm install hexo-generator-search  --save</code></pre><p><strong>enable acticle wordcount</strong></p><pre><code>$ npm install hexo-wordcount --save</code></pre><p><strong>enable generate tag feature and pages</strong></p><pre><code>$ npm install hexo-generator-tag --save</code></pre><p><strong>enable website search feature</strong></p><pre><code>$ npm install hexo-generator-searchdb --save</code></pre><h3 id="Hexo-documentation"><a href="#Hexo-documentation" class="headerlink" title="Hexo documentation"></a>Hexo documentation</h3><p>想要学习更详细的Hexo，<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">传送门</a></p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git Learning</title>
      <link href="/2018/04/05/Git-Learning/"/>
      <url>/2018/04/05/Git-Learning/</url>
      <content type="html"><![CDATA[<h3 id="reopsitory"><a href="#reopsitory" class="headerlink" title="reopsitory"></a>reopsitory</h3><p>库，最基本的概念,需要做版本控制的目录或文件的集合都会保存在一个Repo中，通过Git命令可以看到每一个之前修改过的版本。</p><p>local Repo与Remote Repo可以建立映射关系<br>local repository &lt;&lt;====&gt;&gt; remote repository</p><p>目录c:/user/admin/git/下文件加入到Repo后后，local file可以与remote file可以形成相互备份关系。<br>local directory(c:/user/admin/git/*) &lt;&lt;====&gt;&gt; <a href="https://github.com/username/repository" target="_blank" rel="noopener">https://github.com/username/repository</a>  </p><h3 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h3><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！<br><img src="/2018/04/05/Git-Learning/multiple-world.png" class="multiple world"></p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><img src="/2018/04/05/Git-Learning/repository.png" class="diagram of Repository"><h3 id="Useful-Command"><a href="#Useful-Command" class="headerlink" title="Useful Command"></a>Useful Command</h3><h4 id="初始化-repo"><a href="#初始化-repo" class="headerlink" title="初始化 repo"></a>初始化 repo</h4><pre><code>admin@admin-PC MINGW64 ~   $ mkdir git  $ cd git  $ pwd  /c/Users/admin/git  $ git init   </code></pre><h4 id="添加到版本控制"><a href="#添加到版本控制" class="headerlink" title="添加到版本控制"></a>添加到版本控制</h4><pre><code>$ git add README.txt  $ git commit -m &quot;discript what have done in files&quot; //提交确认修改`</code></pre><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件<br><img src="/2018/04/05/Git-Learning/workround.png" class="work around"></p><h4 id="查看git状态"><a href="#查看git状态" class="headerlink" title="查看git状态"></a>查看git状态</h4><pre><code>$ git status </code></pre><h4 id="查看修改的内容"><a href="#查看修改的内容" class="headerlink" title="查看修改的内容"></a>查看修改的内容</h4><pre><code>$ git diff file </code></pre><h4 id="查看commit-log"><a href="#查看commit-log" class="headerlink" title="查看commit log"></a>查看commit log</h4><pre><code>$ git log         </code></pre><p>很明显这查看表示历史修改版本记录，最主要是看commit id。</p><h4 id="reset到指定的版本"><a href="#reset到指定的版本" class="headerlink" title="reset到指定的版本"></a>reset到指定的版本</h4><pre><code>$ git reset --hard HEAD^ </code></pre><p>表示回退， 至于HEAD主要是与commit id映射，HEAD^表示上一个版本，HEAD~100，表示上100版本！这个鬼记得往上100个版本做了什么… 当然也可以直接写commit id， 更深的理解，commit id保存所有历史版本，<strong>HEAD只是一个指针</strong>。</p><h4 id="reform-log"><a href="#reform-log" class="headerlink" title="reform log"></a>reform log</h4><pre><code>$ git reflog </code></pre><p>这个做什么呢，记录commit id - HEAD - actions的映射关系。方便吃后悔药。</p><pre><code>$ git refloga944eee (HEAD -&gt; master) HEAD@{0}: commit: vertion 2: added time.be90283 HEAD@{1}: commit (initial): edit the readme file</code></pre><h4 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h4><pre><code>$ git checkout -- file   </code></pre><p>只要没有把版本推送到远程库，一切误操作都可以清除。包括是git reset HEAD file。</p><p>####remove file</p><pre><code>$ git rm file </code></pre><p>删除文件，误删除怎么办，上一步刚说过，checkout</p><h4 id="remote-repository"><a href="#remote-repository" class="headerlink" title="remote repository"></a>remote repository</h4><p>Git的天敌是SVN，不过SVN已经在沙滩上了，Git是怎么做到的？ K.O技能：remote repository。 Now，请注册一个Github账号—完全免费共享的remote repository。如果有秘密项目，那么可以自己搭建一个git server。</p><pre><code>$ git remote add origin git@github.com:username/repository   //添加remote git库$ git remote add origin  https://github.com/username/repositor     //另一种方式添加remote repo</code></pre><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><pre><code>$ git push -u origin master     //将本地库推送到remote</code></pre><h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><pre><code>$ git clone git@github.com:username/repository         //同步remote库到本地，通过SSH协议$ git clone https://github.com/username/repository         //通过https协议</code></pre><h4 id="swich-branch"><a href="#swich-branch" class="headerlink" title="swich branch"></a>swich branch</h4><pre><code>$ git checkout -b branchname         </code></pre><p>创建并切换分支。相当于<br>    $ git branch branchname<br>    $ git checkout branchname</p><h4 id="check-branch"><a href="#check-branch" class="headerlink" title="check branch"></a>check branch</h4><pre><code>$ git branch</code></pre><h4 id="merge-branch"><a href="#merge-branch" class="headerlink" title="merge branch"></a>merge branch</h4><pre><code>$ git merge branchname (--no-ff)</code></pre><p>合并branch，no off 表示关闭fast forward模式，将命令中的branch merge到当前workaround的branch。</p><h4 id="delete-branch"><a href="#delete-branch" class="headerlink" title="delete branch"></a>delete branch</h4><pre><code>$ git branch -d branchname</code></pre><h3 id="Git-learning-review"><a href="#Git-learning-review" class="headerlink" title="Git learning review"></a>Git learning review</h3><p>廖雪峰最简单易懂Git学习<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">Git Learning</a></p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tech Blog最佳实践</title>
      <link href="/2018/03/30/tech-blog/"/>
      <url>/2018/03/30/tech-blog/</url>
      <content type="html"><![CDATA[<p><em>本文主要说明构建个人博客需要的所有工具和条件，以及每一个组件在构建blog的说明和作用，并不是完整的操作手册。在搭建博客前通过阅读本文，完整的明白各个组件承担的响应的角色，当遇到问题时可以清楚地确定问题可能发生的原因。推荐完整看完本文后再进入各个组件深入学习。本文阅读时间1小时。</em></p><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><pre><code>Git + Github Pages + Node.js + Hexo + NexT Theme</code></pre><h3 id="knowledge-Base"><a href="#knowledge-Base" class="headerlink" title="knowledge Base"></a>knowledge Base</h3><ul><li><strong>Git</strong> – 熟悉Git的工作原理和怎样使用Git。 推荐时间：2天</li><li><strong>Github</strong> – 练习注册一个 账号<a href="https://www.github.com" target="_blank" rel="noopener">github</a> , 创建并练习使用repository，搭建Github pages。推荐时间： 1天</li><li><strong>Hexo</strong> – 安装Hexo, 设置基本的Hexo配置练习。推荐时间： 1天</li><li><strong>NexT Theme</strong> –从Hexo 默认Theme切换到NexT后，练习自定义主题主要的元素。推荐时间： 0.5天</li><li><strong>Markdown</strong> – 学会使用Markdown的语法编辑文档，通过Markdown编辑器练习使用各种标签。推荐时间：0.5天</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。那什么是版本控制系统？ </p><p>在编辑文档时，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？  </p><p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪，这个软件就是Git。</p><p>还不明白，可以进入廖雪峰老师的文档继续深入学习：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">Git introduction</a>  </p><p>Git下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">Git Download</a></p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Node.js并不需要我们了解怎样使用它。我们只需要知道下面的Hexo能够正常工作需要依赖Node.js。所以只需要知道如何安装：</p><p>下载并安装nvm.（什么是nvm？不需要知道，只需要知道他可以方便安装node.js）</p><ul><li><p>Download nvm </p><pre><code>  $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh    </code></pre></li><li><p>install nvm</p><pre><code>  $ cd .nvm/  $ ./install.sh</code></pre></li><li><p>set bash profile</p><pre><code>  $ export NVM_DIR=&quot;$HOME/.nvm&quot;  $ [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;</code></pre></li><li><p>install Node.js</p><pre><code>  $ nvm install stable</code></pre></li></ul><h3 id="GitHub-Page"><a href="#GitHub-Page" class="headerlink" title="GitHub Page"></a>GitHub Page</h3><p>Github做为Git的云端版本库，可以放任何人随时随地边编辑和发布文档，而且完全开源免费。Github Page作为Github的一个功能，<strong>只需要将站点文件上传到Github上，你可以拥有自己的免费Blog平台，不需要托管主机，不需要域名</strong>。</p><p>account: <em>yourusername</em><br>通过ssh方式连接Github：  </p><pre><code>git@github.com:_yourusername_/</code></pre><p>通过http方式连接Github：  </p><pre><code>https://github.com/_yourusername_/  $ git config --global user.name &quot;Your Name&quot;  $ git config --global user.email &quot;email@example.com&quot;</code></pre><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo</a>  是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。什么意思呢？</p><p>我们知道静网页文件都是<em>.html</em>文件，需要很多标签对格式进行控制。如果我们有Hexo后，我们可以将可读性很高的文本档使用Markdown的语法通过Hexo转换成<em>.html</em>文件，并且生成完整的完整框架。我们只需要编辑文本文件，通hexo生成网站的框架和内容，并且部署生成自己的网站。</p><ul><li><p>Install hexo</p><pre><code>  $npm install hexo-cli -g</code></pre></li><li><p>set up hexo  </p><pre><code>  $hexo init blog  $cd blog  $npm install  $hexo server</code></pre></li></ul><h3 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h3><p>如果说Hexo为一个人的躯体，那么NexT就是这个躯体的衣服，让Hexo变得更美，这就是NexT。</p><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</p><p>安装 NexT<br>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。  </p><p>下载主题  </p><pre><code>$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>启用主题  </p><pre><code>#编辑系统配置文件_config.yml,找到Theme设置并将值改成nexttheme: next</code></pre><p>验证主题  </p><pre><code>$hexo s --debug  INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></pre><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。目前 github、Stackoverflow 等网站均支持这种格式.<br><a href="http://www.markdown.cn/#acknowledgement" target="_blank" rel="noopener">Markdown</a>    </p><p>ENDING  </p><ol><li><p><a href="http://zhaoweihao.me/2017/04/29/Hexo-Github-pages-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">http://zhaoweihao.me/2017/04/29/Hexo-Github-pages-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</a></p></li><li><p><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></p></li></ol>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown Quick Guide</title>
      <link href="/2018/03/29/markdown/"/>
      <url>/2018/03/29/markdown/</url>
      <content type="html"><![CDATA[<p><em>本文主要介绍Markdown的基本使用方法，基本不用了解HTML的语法。按照本文的说明编辑文本后，只要通过Markdown编辑器，就能生成一个html文件。本文阅读时间大约1-2个小时。</em></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的书写语言。</p><h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。</p><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>在插入处先按入两个以上的空格然后回车</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在行首插入 1 到 6 个 #，对应到标题 1 到 6 阶，例如：</p><pre><code># 这是 H1## 这是 H2###### 这是 H6</code></pre><h3 id="区块引用blockquotes"><a href="#区块引用blockquotes" class="headerlink" title="区块引用blockquotes"></a>区块引用blockquotes</h3><p>用 &gt; 的引用方式，例如：</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><p>区块引用可以嵌套，例如：</p><blockquote><blockquote><p>This is nested blockquote.</p></blockquote><p>Back to the first level</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>序列表使用星号、加号或是减号作为列表标记：</p><pre><code>*   Red*   Green*   Blue</code></pre><p>有序列表则使用数字接着一个英文句点：</p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><ul><li>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</li><li>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</li><li>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</li><li>在行首出现数字-句点-空白:<br>  1986. What a great season.</li></ul><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><p>这是一个普通段落：</p><pre><code>这是一个代码区块。</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线</p><pre><code>* * *********- - ----------------------------------------</code></pre><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可:</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.See my [About](/about/) page for details.</code></pre><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>链接内容定义的形式为：</p><pre><code>* 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字* 接着一个冒号* 接着一个以上的空格或制表符* 接着链接的网址* 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</code></pre><p>下面是一个参考式链接的范例：</p><pre><code>I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].    [1]: http://google.com/        &quot;Google&quot;    [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;    [3]: http://search.msn.com/    &quot;MSN Search&quot;</code></pre><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong>，例如：</p><pre><code>*single asterisks*</code></pre><p><em>single asterisks</em></p><pre><code>_single underscores_</code></pre><p><em>single underscores</em></p><pre><code>**double asterisks**</code></pre><p><strong>double asterisks</strong></p><pre><code>__double underscores__</code></pre><p><strong>double underscores</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：</p><pre><code>Use the `printf()` function.</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。<br>行内式的图片语法看起来像是：</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><p>参考式的图片语法则长得像这样：</p><pre><code>![Alt text][id][id]: url/to/image  &quot;Optional title attribute&quot;</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>利用反斜杠来插入一些在语法中有其它意义的符号<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>只要是用方括号包起来， Markdown 就会自动把它转成链接，一般网址的链接文字就和链接地址一样，例如：</p><pre><code>&lt;http://example.com/&gt;</code></pre><h2 id="Markdown-免费编辑器"><a href="#Markdown-免费编辑器" class="headerlink" title="Markdown 免费编辑器"></a>Markdown 免费编辑器</h2><p>Windows 平台</p><ul><li><a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a> </li><li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="noopener">MarkPad</a></li></ul><p>Linux 平台</p><ul><li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="noopener">ReText</a></li></ul><p>Mac 平台</p><ul><li><a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a></li></ul><p>在线编辑器</p><ul><li><a href="http://markable.in/" target="_blank" rel="noopener">Markable.in</a></li><li><a href="http://dillinger.io/" target="_blank" rel="noopener">Dillinger.io</a></li></ul><p>浏览器插件</p><ul><li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="noopener">MaDe (Chrome)</a></li></ul><p>高级应用(Sublime Text 2 + MarkdownEditing 教程)</p><ul><li><a href="http://www.sublimetext.com/2" target="_blank" rel="noopener">Sublime Text 2</a></li><li><a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="noopener">MarkdownEditing</a></li><li><a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="noopener">教程</a></li></ul><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢: <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">http://daringfireball.net/projects/markdown/</a></p><p>原文：<a href="http://www.markdown.cn/#overview" target="_blank" rel="noopener">http://www.markdown.cn/#overview</a> </p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> HTML </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>post picture</title>
      <link href="/2018/03/27/post-picture/"/>
      <url>/2018/03/27/post-picture/</url>
      <content type="html"><![CDATA[<p>Totoro<br><img src="/2018/03/27/post-picture/download.jpg" class="Totoro"><br></p>content]]></content>
      
      <categories>
          
          <category> film </category>
          
      </categories>
      
      
        <tags>
            
            <tag> film </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>boyhood</title>
      <link href="/2018/03/15/boyhood/"/>
      <url>/2018/03/15/boyhood/</url>
      <content type="html"><![CDATA[<p>教程<br><blockquote><p>史上最浅显易懂的Git教程！</p><footer><strong>Liaoxuefeng</strong><cite><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></cite></footer></blockquote><br>Code<br><pre><code>#!&#x2F;bin&#x2F;bashfor (i=0,i++,i&lt;a)do i=i++;echo $i;done</code></pre></p><p>Link<br><a href="http://www.freebuf.com/news/166362.html" title="IETF批准TLS 1.3为互联网标准" target="_blank" rel="noopener">互联网工程任务组（IETF）已正式批准TLS 1.3作为传输层安全（TLS）协议的下一个主要版本，IETF组织是专门批准互联网标准和协议的组织。</a></p>]]></content>
      
      <categories>
          
          <category> film </category>
          
      </categories>
      
      
        <tags>
            
            <tag> film </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《朝花夕拾》</title>
      <link href="/2018/03/15/hello-world/"/>
      <url>/2018/03/15/hello-world/</url>
      <content type="html"><![CDATA[<blockquote><p> 我常想在纷扰中寻出一点闲静来，然而委实不容易。目前是这么离奇，心里是这么芜杂。一个人做到只剩了回忆的时候，生涯大概总要算是无聊了罢，但有时竟会连回忆也没有。</p></blockquote><blockquote><p>前天，已将《野草》编定了；这回便轮到陆续载在《莽原》上的《旧事重提》，我还替他改了一个名称：《朝花夕拾》。带露折花，色香自然要好得多，但是我不能够。便是现在心目中的离奇和芜杂，我也还不能使他即刻幻化，转成离奇和芜杂的文章。或者，他日仰看流云时，会在我的眼前一闪烁罢。</p></blockquote><blockquote><p>我有一时，曾经屡次忆起儿时在故乡所吃的蔬果：菱角、罗汉豆、茭白、香瓜。凡这些，都是极其鲜美可口的；都曾是使我思乡的蛊惑。后来，我在久别之后尝到了，也不过如此；惟独在记忆上，还有旧来的意味留存。他们也许要哄骗我一生，使我时时反顾。</p></blockquote><p><em><p align="right">——《朝花夕拾》小引</p></em><br>正如鲁迅先生给文集取名《朝花夕拾》一样，当我第一次感觉到每天忙于各种凌杂的琐碎，无暇去思考和记录做过的一些工作，而当再次拿起这些工作时，记忆是那么的空白，没有一点线索可以现成的找寻。想想在这些年的工作中，有做过不少研究和探索，零散的记录在不同的地方，或是在纸质的笔记本上，在不同的文件夹中，在在线软件文档中，有些干脆没有记录，只是在大脑中保存一点记忆。<br>取名《朝花夕拾》这个寓意很好，这些年来工作中，重新整理那些有意义的资料文档，即可归纳总结多年来工作的成绩，也保存有价值的历史资料或记忆。</p><blockquote><p>回忆，我发现，可能是不可靠的东西，尝尝被你回忆时的环境所大大的扭曲。</p></blockquote><p><em><p align="right">——《远山淡影》石黑一雄</p></em></p><p>当石黑一雄获得诺贝尔文学奖时，当我我看《远山淡影》这本书时，没忍住买了一本但是没怎么看懂。后来一次去一家书店阅读时，看到上面这段书评，心中瞬间被这就句话触动了。回想阅读这本书时的情节突然就想通了。 </p><p>记忆，可不就是这样吗？曾经很熟悉的知识内容，在时间的冲淡下，常常只有一个模糊印象，更糟糕的是将几个不相关的片段串在一起。对于技术这个来说，太要糟糕了，当再去想用过的东西还需要不停的调试和排错，这对效率来说是巨大的损失，对精力是巨大的折磨。我们太需要这种实实在在东西将我们印象的东西记录下来。</p><blockquote><p>Without you,who would I admire all the beautiful things with.<br>“没有你 良辰美景可与何人说。”  </p></blockquote><p><em><p align="right">——《天使爱美丽》台词</p></em></p><p>最后，我要说的是，对于关于Share这件事，我想这也是Github的核心精神，将自己的贡献上传到公共的平台上，不仅是一个免费展示自己的平台，而且让那些需要的人可以浏览和下载。在Share中获得快乐，同时又可以帮助他人，这或许也是一种自我实现。</p><p>这大概就是我记录博客的初衷吧。</p>]]></content>
      
      
    </entry>
    
  
  
</search>
